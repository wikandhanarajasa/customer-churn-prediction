# -*- coding: utf-8 -*-
"""Copy of FP Telecom_Work Plan

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IIpXilTUf7ZkQL-M7DBVPqdOKfLvZSIC

#**Analysis of Churn Customer**

##Introduction

Interconnect is telecomunication company that focus on landline and internet service. Aside from those two services, it also offers other service such as Internet Security, Tech Support, Cloud Storage, Online Backup and Streaming Service.

In order to maintain the business stays profitable, the company decided to deepen analize their customers by forecast their churn rate. Any potential churn client will be offer promotion code and special package to keep them using the service.

The marketing team has been gathered the data needed to run the analysis such as client information, contract and current service.

##Goal

The goals of this project are as below:
1. Having a proper machine learning model to predict client churn with AUC-ROC as main metric with score exceeding or equal to 0.88.
2. Having F1 score as additional metric.
3. Having statistic calculation and visualization the findings.
4. Having comparation behaviour of telephone and internet users.

##Steps

The steps of this project are as below:
1. Load the data and study the general information.
2. Explore and analysis the data.
3. Prepare the data if anomalies were found & check the class balance.
4. Create machine learning model & train the model while maintain AUC-ROC score above or equal to 0.88.
5. Draw the conclusion.

###Data Loadment
"""

#Data Manipulation and Analysis Libraries
import pandas as pd
import numpy as np

#Data Visualization Libraries
import matplotlib.pyplot as plt
import seaborn as sns

#Loading Dataset
path_contract = '/content/contract.csv'
path_personal = '/content/personal.csv'
path_internet = '/content/internet.csv'
path_phone = '/content/phone.csv'

data_contract = pd.read_csv(path_contract)
data_personal = pd.read_csv(path_personal)
data_internet = pd.read_csv(path_internet)
data_phone = pd.read_csv(path_phone)

"""####Data Contract

Understand and checking the general information of the data and looking for anomalies of data contract.
"""

data_contract.head(3)

data_contract.shape

data_contract.info()

data_contract.isnull().sum()

data_contract.duplicated().sum()

"""- Since the date data are originally have the type of object, we can convert into datetime type in case we will use it for future analysis.
- The type of the data in column TotalCharges is object and we can convert it into float.

"""

data_contract['BeginDate'] = pd.to_datetime(data_contract['BeginDate'], format='%Y-%m-%d', errors='coerce')
data_contract['EndDate'] = pd.to_datetime(data_contract['EndDate'], format='%Y-%m-%d %H:%M:%S', errors='coerce')

data_contract['TotalCharges'] = pd.to_numeric(data_contract['TotalCharges'], errors='coerce').astype('float64')

data_contract.info()

data_contract.head(3)

"""Columns of Data Contract:
1. **customerID**: A unique identifier assigned to each customer.
2. **BeginDate**: The date when the customer's contract started.
3. **EndDate**: The date when the customer's contract ended, if its an active customer the column filled with NaT.
4. **Type**: The type of contract the customer has signed up for. This could indicate the duration (e.g., month-to-month, one year, two years) or the nature of the service package.
5. **PaperlessBilling**: Indicates whether the customer has opted for paperless billing.
6. **PaymentMethod**:The method chosen by the customer to make payments.
7. **MonthlyCharges**: The amount charged to the customer every month for the services provided.
8. **TotalCharges**: The total amount charged to the customer over the course of their contract.

####Data Personal

Understand and checking the general information of the data and looking for anomalies of data personal.
"""

data_personal.head(3)

data_personal.shape

data_personal.info()

data_personal.isnull().sum()

data_personal.duplicated().sum()

"""Columns of Data Personal:

1. **customerID**: A unique identifier assigned to each customer.
2. **gender**: The gender of the custumers.
3. **SeniorCitizen**: Boolean data that indicated whether the customer is a senior citizen or not where 1 means yes and 0 means no.
4. **Partner**: Binary data that indicates whether the customer has a partner or spouse.
5. **Dependents**: Binary data that indicates whether the customer has dependents (such as children or other family members they care for).

####Data Internet

Understand and checking the general information of the data and looking for anomalies of data internet.
"""

data_internet.head(3)

data_internet.shape

data_internet.info()

data_internet.isnull().sum()

data_internet.duplicated().sum()

"""Columns of Data Internet:

1. **customerID**: A unique identifier assigned to each customer.
2. **InternetService**: Indicates the type of internet service the customer subscribes to.
3. **OnlineSecurity**: Binary data that indicates whether the customer has subscribed to an online security service.
4. **OnlineBackup**: Binary data that indicates whether the customer has subscribed to an online backup service.
5. **DeviceProtection**: Binary data that indicates whether the customer has subscribed to a device protection service.
6. **TechSupport**: Binary data that indicates whether the customer has access to technical support.
7. **StreamingTV**: Binary data that indicates whether the customer subscribes to a TV streaming service.
8. **StreamingMovies**: Binary data that indicates whether the customer subscribes to a movie streaming service.

####Data Phone

Understand and checking the general information of the data and looking for anomalies of data personal.
"""

data_phone.head(3)

data_phone.shape

data_phone.info()

data_phone.isnull().sum()

data_phone.duplicated().sum()

"""Columns of Data Internet:

1. **customerID**: A unique identifier assigned to each customer.
2. **MultipleLines**: Binary data that indicates whether the customer has multiple phone lines.

###Exploratory Data Analysis

Since data study has been conducted and anomalies were fixed, exploratory and analysis need to be done in order to have brief understanding of the existing condition of Interconnect customer.

Merge data in order to make the analysis easier by combining all 4 data using inner merge on customerID. Inner merge will be use to avoid the empty information if a difference found in customerID in each data.
"""

data = pd.merge(data_personal, data_internet, on='customerID', how='inner')

data.shape

data.isnull().sum()

data.duplicated().sum()

data = pd.merge(data_phone, data, on='customerID', how='inner')

data.shape

data.isnull().sum()

data = pd.merge(data_contract, data, on='customerID', how='inner')

data.shape

data.isnull().sum()

data['EndDate'].unique()

"""The null data in column EndDate means the customer is an active customer. In order to have better understanding, we will fill the null value with 0 to further indicate in additional column of binary value that 0 means active customer and 1 means churn customer."""

data['EndDate'] = data['EndDate'].fillna(0)

data.head(3)

"""We will add new column named churn to be fill with binary value of 0 and 1 where 1 means churn and 0 means active customer."""

data['churn'] = data['EndDate'].apply(lambda x: 0 if x == 0 else 1)

data.head(3)

data.info()

"""####Churn Custumer vs Average Charges"""

graph_1 = pd.pivot_table(data, index='churn', values=['MonthlyCharges', 'TotalCharges'], aggfunc='mean').reset_index()
graph_1['churn'] = graph_1['churn'].replace({1: 'churn customer', 0: 'active customer'})
graph_1

data['Active'] = data['churn'].apply(lambda x: 'Yes' if x == 0 else 'No')

data.head(3)

plt.figure(figsize=(6, 4))
sns.violinplot(data=data, x='MonthlyCharges', y='Active')

plt.title('Violin Plot of Monthly Charges by Churn')
plt.xlabel('Total Charges')
plt.ylabel('Active Status')
plt.show()

plt.figure(figsize=(6, 4))
sns.barplot(x='churn', y='value', hue='variable',
            data=pd.melt(graph_1, id_vars='churn', value_vars=['TotalCharges']))

plt.title('Average Monthly and Total Charges by Customer Status')
plt.xlabel('Customer Status')
plt.ylabel('Average Charges')
plt.legend(title='Charges Type')
plt.show()

"""Finding:

1. Active customer have almost the same monthly spending and more on total spending. This could happenned by factor like the time of the data being retrieved and churn customer no longer pay for service.
2. Churn customer tend to pay more compare to active customer where we can study from the violin plot.

####Churn Customer vs Type of Contract
"""

graph_2 = pd.pivot_table(data, index='Type', columns='churn', values='customerID', aggfunc='count')
graph_2 = graph_2[[1]].rename(columns={1: 'Total_Churn'})
graph_2 = graph_2.reset_index()
graph_2

plt.figure(figsize=(6, 4))
sns.barplot(x='Type', y='Total_Churn', data=graph_2)
plt.title('Total Churn by Type of Contract')
plt.xlabel('Type')
plt.ylabel('Total Churn')
plt.show()

"""Finding:

1. Customer that renew the contract monthly tend to terminate the service.
2. This could happened because the customer would like to do a trial of one month to experience the service provided.

####Churn Customer vs Payment Method
"""

graph_3 = pd.pivot_table(data, index='PaymentMethod', columns='churn', values='customerID', aggfunc='count').reset_index()
graph_3 = graph_3[['PaymentMethod', 1]].rename(columns={1: 'Total_Churn'}).reset_index()
graph_3 = graph_3.sort_values(by='Total_Churn', ascending=False).reset_index(drop=True)
graph_3

plt.figure(figsize=(10, 4))
sns.barplot(x='PaymentMethod', y='Total_Churn', data=graph_3)

for index, row in graph_3.iterrows():
    plt.text(index, row['Total_Churn'], str(row['Total_Churn']), ha='center', va='bottom')

plt.title('Total Churn by Payment Method')
plt.xlabel('Payment Method')
plt.ylabel('Total Churn')
plt.show()

graph_3b = pd.pivot_table(data, index='PaymentMethod', columns='churn', values='customerID', aggfunc='count').reset_index()
graph_3b = graph_3b[['PaymentMethod', 0]].rename(columns={0: 'Active_Customer'}).reset_index()
graph_3b = graph_3b.sort_values(by='Active_Customer', ascending=False).reset_index(drop=True)
graph_3b

plt.figure(figsize=(10, 4))
sns.barplot(x='PaymentMethod', y='Active_Customer', data=graph_3b)

for index, row in graph_3b.iterrows():
    plt.text(index, row['Active_Customer'], str(row['Active_Customer']), ha='center', va='bottom')

plt.title('Active Customer by Payment Method')
plt.xlabel('Payment Method')
plt.ylabel('Active Customer')
plt.show()

"""Finding:

1. The finding in churn customer vs type of contract validated by their payment method where it tend to pay manually instead of autodebit.
2. The active customer tend not to have any significant differences behaviour in paying their subscription.

####Churn Customer vs Gender
"""

graph_4 = pd.pivot_table(data, index='gender', columns='churn', values='customerID', aggfunc='count').reset_index()
graph_4 = graph_4[['gender', 1]].rename(columns={1: 'Total_Churn'}).reset_index()
graph_4 = graph_4.sort_values(by='Total_Churn', ascending=False).reset_index(drop=True)
graph_4

"""Finding:

1. There is no significant different between male and female in term of cancelation of service.

####Churn Customer vs Senior Citizen
"""

graph_5 = pd.pivot_table(data, index='SeniorCitizen', columns='churn', values='customerID', aggfunc='count').reset_index()
graph_5 = graph_5[['SeniorCitizen', 1]].rename(columns={1: 'Total_Churn'}).reset_index()
graph_5 = graph_5.sort_values(by='Total_Churn', ascending=False).reset_index(drop=True)
graph_5

plt.figure(figsize=(10, 4))
sns.barplot(x='SeniorCitizen', y='Total_Churn', data=graph_5)

for index, row in graph_5.iterrows():
    plt.text(index, row['Total_Churn'], str(row['Total_Churn']), ha='center', va='bottom')

plt.title('Total Churn by Type of Citizen')
plt.xlabel('Senior Citizen')
plt.ylabel('Total Churn')
plt.show()

graph_5b = pd.pivot_table(data, index='SeniorCitizen', columns='churn', values='customerID', aggfunc='count').reset_index()
graph_5b = graph_5b[['SeniorCitizen', 0]].rename(columns={0: 'Active_Customer'}).reset_index()
graph_5b = graph_5b.sort_values(by='Active_Customer', ascending=False).reset_index(drop=True)
graph_5b

plt.figure(figsize=(10, 4))
sns.barplot(x='SeniorCitizen', y='Active_Customer', data=graph_5b)

for index, row in graph_5b.iterrows():
    plt.text(index, row['Active_Customer'], str(row['Active_Customer']), ha='center', va='bottom')

plt.title('Total Active Customer by Type of Citizen')
plt.xlabel('Senior Citizen')
plt.ylabel('Active Customer Churn')
plt.show()

"""Finding:

1. There is no significant differences in terms of whether its senior citizen or not in case of cancelation of service.

####Churn Customer vs Partnership
"""

graph_6 = pd.pivot_table(data, index='Partner', columns='churn', values='customerID', aggfunc='count').reset_index()
graph_6

graph_6 = pd.pivot_table(data, index='Partner', columns='churn', values='customerID', aggfunc='count').reset_index()
graph_6 = graph_6[['Partner', 1]].rename(columns={1: 'Total_Churn'}).reset_index()
graph_6 = graph_6.sort_values(by='Total_Churn', ascending=False).reset_index(drop=True)
graph_6

plt.figure(figsize=(10, 4))
sns.barplot(x='Partner', y='Total_Churn', data=graph_6)

for index, row in graph_6.iterrows():
    plt.text(index, row['Total_Churn'], str(row['Total_Churn']), ha='center', va='bottom')

plt.title('Total Churn by Type of Partnership')
plt.xlabel('Partnership')
plt.ylabel('Total Churn')
plt.show()

"""Findings:

1. There is no significant differences in terms of whether its in partnership or not in case of cancelation of service.

####Churn Customer vs Dependenship
"""

graph_7 = pd.pivot_table(data, index='Dependents', columns='churn', values='customerID', aggfunc='count').reset_index()
graph_7

graph_7 = pd.pivot_table(data, index='Dependents', columns='churn', values='customerID', aggfunc='count').reset_index()
graph_7 = graph_7[['Dependents', 1]].rename(columns={1: 'Total_Churn'}).reset_index()
graph_7 = graph_7.sort_values(by='Total_Churn', ascending=False).reset_index(drop=True)
graph_7

plt.figure(figsize=(10, 4))
sns.barplot(x='Dependents', y='Total_Churn', data=graph_7)

for index, row in graph_7.iterrows():
    plt.text(index, row['Total_Churn'], str(row['Total_Churn']), ha='center', va='bottom')

plt.title('Total Churn by Type of Dependenship')
plt.xlabel('Dependenship')
plt.ylabel('Total Churn')
plt.show()

graph_7b = pd.pivot_table(data, index='Dependents', columns='churn', values='customerID', aggfunc='count').reset_index()
graph_7b = graph_7b[['Dependents', 1]].rename(columns={1: 'Active_Customer'}).reset_index()
graph_7b = graph_7b.sort_values(by='Active_Customer', ascending=False).reset_index(drop=True)
graph_7b

plt.figure(figsize=(10, 4))
sns.barplot(x='Dependents', y='Active_Customer', data=graph_7b)

for index, row in graph_7b.iterrows():
    plt.text(index, row['Active_Customer'], str(row['Active_Customer']), ha='center', va='bottom')

plt.title('Total Active Customer by Type of Dependenship')
plt.xlabel('Dependenship')
plt.ylabel('Active Customer Churn')
plt.show()

"""Finding:

1. There is no significant differences in terms of whether its has any dependenship or not in case of cancelation of service.

####Churn Customer vs Lines Services
"""

graph_8 = pd.pivot_table(data, index='MultipleLines', columns='churn', values='customerID', aggfunc='count').reset_index()
graph_8

graph_8 = pd.pivot_table(data, index='MultipleLines', columns='churn', values='customerID', aggfunc='count').reset_index()
graph_8 = graph_8[['MultipleLines', 1]].rename(columns={1: 'Total_Churn'}).reset_index()
graph_8 = graph_8.sort_values(by='Total_Churn', ascending=False).reset_index(drop=True)
graph_8

plt.figure(figsize=(10, 4))
sns.barplot(x='MultipleLines', y='Total_Churn', data=graph_8)

for index, row in graph_8.iterrows():
    plt.text(index, row['Total_Churn'], str(row['Total_Churn']), ha='center', va='bottom')

plt.title('Total Churn by Line Service')
plt.xlabel('Line Service')
plt.ylabel('Total Churn')
plt.show()

"""Finding:

1. There is no significant differences in type of line service in case of cancelation of service.

####Churn Customer vs Add-on Service

#####Internet Service
"""

graph_9 = pd.pivot_table(data, index='InternetService', columns='churn', values='customerID', aggfunc='count').reset_index()
graph_9

graph_9 = pd.pivot_table(data, index='InternetService', columns='churn', values='customerID', aggfunc='count').reset_index()
graph_9 = graph_9[['InternetService', 1]].rename(columns={1: 'Total_Churn'}).reset_index()
graph_9 = graph_9.sort_values(by='Total_Churn', ascending=False).reset_index(drop=True)
graph_9

plt.figure(figsize=(10, 4))
sns.barplot(x='InternetService', y='Total_Churn', data=graph_9)

for index, row in graph_9.iterrows():
    plt.text(index, row['Total_Churn'], str(row['Total_Churn']), ha='center', va='bottom')

plt.title('Total Churn by Internet Service')
plt.xlabel('Internet Service')
plt.ylabel('Total Churn')
plt.show()

"""#####TV Streaming"""

graph_10 = pd.pivot_table(data, index='StreamingTV', columns='churn', values='customerID', aggfunc='count').reset_index()
graph_10

graph_10 = pd.pivot_table(data, index='StreamingTV', columns='churn', values='customerID', aggfunc='count').reset_index()
graph_10 = graph_10[['StreamingTV', 1]].rename(columns={1: 'Total_Churn'}).reset_index()
graph_10 = graph_10.sort_values(by='Total_Churn', ascending=False).reset_index(drop=True)
graph_10

plt.figure(figsize=(10, 4))
sns.barplot(x='StreamingTV', y='Total_Churn', data=graph_10)

for index, row in graph_10.iterrows():
    plt.text(index, row['Total_Churn'], str(row['Total_Churn']), ha='center', va='bottom')

plt.title('Total Churn by Streaming TV Service')
plt.xlabel('Streaming TV Service')
plt.ylabel('Total Churn')
plt.show()

"""#####Technical Support"""

graph_11 = pd.pivot_table(data, index='TechSupport', columns='churn', values='customerID', aggfunc='count').reset_index()
graph_11

graph_11 = pd.pivot_table(data, index='TechSupport', columns='churn', values='customerID', aggfunc='count').reset_index()
graph_11 = graph_11[['TechSupport', 1]].rename(columns={1: 'Total_Churn'}).reset_index()
graph_11 = graph_11.sort_values(by='Total_Churn', ascending=False).reset_index(drop=True)
graph_11

plt.figure(figsize=(10, 4))
sns.barplot(x='TechSupport', y='Total_Churn', data=graph_11)

for index, row in graph_11.iterrows():
    plt.text(index, row['Total_Churn'], str(row['Total_Churn']), ha='center', va='bottom')

plt.title('Total Churn by Tech Support Service')
plt.xlabel('Tech Support Service')
plt.ylabel('Total Churn')
plt.show()

"""#####Online Security"""

graph_12 = pd.pivot_table(data, index='OnlineSecurity', columns='churn', values='customerID', aggfunc='count').reset_index()
graph_12

graph_12 = pd.pivot_table(data, index='OnlineSecurity', columns='churn', values='customerID', aggfunc='count').reset_index()
graph_12 = graph_12[['OnlineSecurity', 1]].rename(columns={1: 'Total_Churn'}).reset_index()
graph_12 = graph_12.sort_values(by='Total_Churn', ascending=False).reset_index(drop=True)
graph_12

plt.figure(figsize=(10, 4))
sns.barplot(x='OnlineSecurity', y='Total_Churn', data=graph_12)

for index, row in graph_12.iterrows():
    plt.text(index, row['Total_Churn'], str(row['Total_Churn']), ha='center', va='bottom')

plt.title('Total Churn by Online Security Service')
plt.xlabel('Online Security Service')
plt.ylabel('Total Churn')
plt.show()

"""Finding:

1. The fiber optic user tend to end the service compare to DSL, where the active customer tend to use both fiber optic and DSL equally.
2. There is no significant differences in terms of streaming service in cancelation.
3. The customer that did not include technical support tend to cancel their subscription.
4. The customer that did not include online security tend to cancel their subscription.

###Monthly Payment Distribution
"""

data_bill = data[['customerID', 'MonthlyCharges', 'churn']]

data_bill.shape

data_bill.head(3)

data_bill_churn = data_bill.loc[(data_bill['churn'] == 1)]

data_bill_stay = data_bill.loc[(data_bill['churn'] == 0)]

q1_bill = data_bill_churn['MonthlyCharges'].describe()['25%']
q3_bill = data_bill_churn['MonthlyCharges'].describe()['75%']
iqr_bill = q3_bill - q1_bill

lower_whisker_bill = q1_bill - 1.5 * iqr_bill
upper_whisker_bill = q3_bill + 1.5 * iqr_bill

print("Q1 Churn Customer:", q1_bill)
print("Q3 Churn Customer:", q3_bill)
print("Interquartile Range (IQR) Churn Customer:", iqr_bill)
print("Lower Whisker Churn Customer:", lower_whisker_bill)
print("Upper Whisker Churn Customer:", upper_whisker_bill)

q1_bill = data_bill_stay['MonthlyCharges'].describe()['25%']
q3_bill = data_bill_stay['MonthlyCharges'].describe()['75%']
iqr_bill = q3_bill - q1_bill

lower_whisker_bill = q1_bill - 1.5 * iqr_bill
upper_whisker_bill = q3_bill + 1.5 * iqr_bill

print("Q1 Stay Custumer:", q1_bill)
print("Q3 Stay Custumer:", q3_bill)
print("Interquartile Range (IQR) Stay Custumer:", iqr_bill)
print("Lower Whisker Stay Custumer:", lower_whisker_bill)
print("Upper Whisker Stay Custumer:", upper_whisker_bill)

sns.histplot(data_bill_stay['MonthlyCharges'], bins=15, label='Active Customers', color='blue', alpha=0.5)
sns.histplot(data_bill_churn['MonthlyCharges'], bins=15, label='Churned Customers', color='red')
plt.xlabel('Monthly Charges')
plt.ylabel('Customer')
plt.title('Monthly Charges Distribution: Churned vs Active Customers')
plt.legend()
plt.show()

plt.figure(figsize=(4, 2))
sns.boxplot(data=data_bill_churn, x='MonthlyCharges')
plt.show()

plt.figure(figsize=(4, 2))
sns.boxplot(data=data_bill_stay, x='MonthlyCharges')
plt.show()

mean_monthly_charges = data_bill.groupby('churn')['MonthlyCharges'].mean().reset_index()
mean_monthly_charges.columns = ['Churn', 'Mean_MonthlyCharges']
mean_monthly_charges.head(3)

plt.figure(figsize=(10, 4))
sns.barplot(x='Churn', y='Mean_MonthlyCharges', data=mean_monthly_charges)

for index, row in mean_monthly_charges.iterrows():
    plt.text(index, row['Mean_MonthlyCharges'], str(row['Mean_MonthlyCharges']), ha='center', va='bottom')

plt.title('Average Monthly Charge')
plt.xlabel('Churn Category')
plt.ylabel('Monthly Charges')
plt.show()

"""###Telephone vs Internet User"""

data_int = pd.merge(data_internet, data_contract, on='customerID', how='outer')

data_int.shape

data_int['InternetService'] = data_int['InternetService'].fillna('No Service')
data_int['internet_user'] = data_int['InternetService'].apply(lambda x: 'No Internet Service' if x == 'No Service' else 'With Internet Service')

print(data_int['internet_user'].unique())
data_int.head(3)

data_int['internet_user'].unique()

internet_user = data_int[['customerID', 'internet_user']]
internet_user.head(2)

internet_user_counts = data_int['internet_user'].value_counts()

plt.figure(figsize=(8, 6))
plt.pie(internet_user_counts, labels=internet_user_counts.index, autopct='%1.1f%%', startangle=140, colors=['blue', 'red'])
plt.title('Internet User Distribution')
plt.show()

data_phone.info()

data_pho = pd.merge(data_contract, data_phone, on='customerID', how='outer')

data_pho.shape

data_pho['MultipleLines'] = data_pho['MultipleLines'].fillna('No Service')
data_pho['phone_user'] = data_pho['MultipleLines'].apply(lambda x: 'No Phone Service' if x == 'No Service' else 'With Phone Service')

print(data_pho['phone_user'].unique())
data_pho.head(3)

phone_user = data_pho[['customerID', 'phone_user']]
phone_user.head(2)

phone_user_counts = phone_user['phone_user'].value_counts()

plt.figure(figsize=(8, 6))
plt.pie(phone_user_counts, labels=phone_user_counts.index, autopct='%1.1f%%', startangle=140, colors=['blue', 'red'])
plt.title('Phone User Distribution')
plt.show()

"""###Summary

Based on statistical calculation for monthly payment distribution between churn and stay customer, the result are as below:

1. 1st Quartile
  - Q1 Churn Customer: 72.2125
  - Q1 Stay Custumer: 68.15

2. 3rd Quartile
  - Q3 Churn Customer: 95.45
  - Q3 Stay Custumer: 95.95

3. Interquartile Range (IQR)
  - Churn Customer: 23.237499999999997
  - Stay Custumer: 27.799999999999997

4. Lower Whisker
  - Churn Customer: 37.35625000000001
  - Stay Custumer: 26.45000000000001

5. Upper Whisker
  - Churn Customer: 130.30625
  - Stay Custumer: 137.65

6. Average Monthly Charge
  - Churn: 82.25000
  - Stay: 81.51362

There is no significant difference when it comes to average monthly payment between churn customer and stay customer. The distribution of monthly charges shows that churn customers generally pay slightly higher charges on average and have a smaller interquartile range compared to stay customers. This indicates that churn customers' monthly charges are less variable and are slightly higher overall. The whiskers suggest that stay customers have both lower minimum and higher maximum charges, suggesting a wider spread of monthly charges among stay customers.

Based on statistical calculation for distribution of customer who using the service of telephone and phone, the result are as below:

1. Only 21.7% of customer do not include the internet service on their plan, meanwhile the rest 78.3% are covered by internet service.
2. Only 9.7% of customer do not include the phone service on their plan, meanwhile the rest 90.3% are covered by phone service.

##Work Plan

As stated before, the goal of this project is to have machine learning model to predict potential churn customer. The indicator of success of this project is having AUC - ROC above or equal to 0.88. Therefore the working plan is as below:

1. Data preparation. Start with little adjustment of font fot the data, make sure to have proper type of data, etc. The next steps are one-hot-encoding the united data since categorycal data has found.
2. Creating machine learning model. After the data proper to develop the machine learning model. We can start with spliting data into target and feature also deleted the unecessary columns.
- Target data: churn
- Feature data: Type, PaperlessBilling, PaymentMethod, MonthlyCharges, TotalCharges, MultipleLines, gender, SeniorCitizen, Partner, Dependents, InternetService, OnlineSecurity, OnlineBackup, DeviceProtection, TechSupport, StreamingTV and StreamingMovies.
- Unecessary data: customerID, BeginDate and EndDate.
3. Split the data into test and train, where 20% is the test size.
4. Develop loop for checking the AUC-ROC score.
5. Several model will be try such as logistic regression, random forest classifier or XG Boost Classifier.
6. Draw conclusion.
"""

